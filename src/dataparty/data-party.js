'use strict'

const ROSLIB = require('roslib')

const Qb = require('./qb.js')
const Query = require('./query.js')
const LokiCache = require('./loki-cache.js') // insert | populate cache
const DataModel = require('./data-model')
const Document = require('./document')

/**
 * @class 
 * @alias module:roshub.DataParty
 * @interface
 */
class DataParty {

  constructor ({ config }) {
    this.config = config
    this.cache = new LokiCache()

    this.qb = new Qb({
      call: this.call.bind(this),
      cache: this.cache
    })
    
    /**
     * @member model 
     * @type {DataModel} */
    this.model = new DataModel({party: this})
  }

  /** @type {Document} */
  get Document(){
    return Document
  }

  /** @type {ROSLIB} */
  get ROSLIB(){
    return ROSLIB
  }

  /** @method */
  async start(){

    return Promise.all([
      this.config.start(),
      this.cache.start()
    ])

  }

  /**
   * @method
   */
  async call(msg){
    throw new Error('Not Implemented')
  }

  /**
   * @method
   */
  async socket(reuse){
    throw new Error('Not Implemented')
  }

  /**
   * @method
   */
  get types(){
    return this.model.getFactories()
  }

  /**
   * @method
   */
  createDocument(type, ...options){
    let Type = this.types[type]
    //debug(Type)

    return Type.create(this, {...options, type})
  }

/*
  * dataParty.find()
  *   .type('user')
  *   .id('xxx') // .ids([..])
  *   .select('profile.photo')
  *   .exec(true)
  *   .then((msg) => { // promise resolves to msg with _id & profile.photo ->
  *     ..             // { _id: '..', profile: { photo: '..' } }
  *   }
  *
  * dataParty.find()
  *   .type('process')
  *   .where('location').equals('mod')
  *   .select('units')
  *   .watch()
  *   -> observer that streams list of units in process & again on changes
  *
  * dataParty.find() // query with no type searches *all* tables
  *   .where('location').equals('mod')
  *   .where('status').equals('ERROR')
  *   .watch()
  *   -> observer that streams list of all msgs with ERROR status at mod
  */
 /**
   * @method
   */
  find () {
    return new Query(this.qb, this.model)
  }

  // takes modified json msgs & writes to backend, resolves to new stamps
  // requires type & id
  /**
   * @method
   */
  update (...msgs) {
    return this.qb.modify(msgs, 'update')
  }

/*
  * inserts one or more msgs of given type into backend
  *
  * dataParty.create('device', { name: 'moonbot', .. })
  *   .then((msg) => {
  *     ..
  *   })
  *
  * create returns a deep copy of given objects as new generic javascript
  * objects with three metadata properties '_type' '_id'
  *
  * msg -> {
  *   _type: 'device', // name of backend message collection passed as arg
  *   _id: '..', // id string generated by backend db
  *   name: 'moonshot', // properties passed to create
  *   ..
  * }
  */
 /**
   * @method
   */
  create (type, ...msgs) {
    return this.qb.create(type, msgs)
  }

/*
 * removes msgs listed (requires type & id)
 * * resolves to headers of removed msgs
 *
 * dataParty.find('device').id('xxx').get()
 *   .then((msg) => {
 *      dataParty.remove('device',
 *        msg,
 *        new Doc({ id='yyy' })
 *      )
 *        .then((removed) => { // [removedDoc0 .. removedDocN]
 *           ..
 *        })
 *   })
 */
/**
   * @method
   */
  remove (...msgs) {
    return this.qb.modify(msgs, 'remove')
  }
}

module.exports = DataParty